# Mini Blog Application

This is a simple mini-blog application built with Next.js, designed to allow users to create, view, and manage blog posts. It features a clean, responsive user interface and integrates with a database for persistent storage and Cloudinary for image management.




## Code Organization

The project follows a standard Next.js application structure, with a clear separation of concerns to enhance maintainability and scalability. Below is an overview of the key directories and their purposes:

-   **`/app`**: This directory contains the core application logic, including pages, API routes, and shared components. It leverages Next.js 13's App Router for routing and data fetching.
    -   **`/app/api`**: Houses all API routes, providing a backend for the frontend. This includes endpoints for managing posts (fetching, creating, updating, deleting) and handling image uploads.
        -   **`/app/api/posts`**: Contains the API routes related to blog posts, such as `route.js` for fetching all posts and creating new ones, and `[id]/route.js` for handling individual post operations (fetching by ID, updating, deleting).
        -   **`/app/api/posts/upload`**: Dedicated API route for handling image uploads to Cloudinary.
    -   **`/app/components`**: Reusable React components used across the application, such as `Header.jsx` for navigation and `Footer.jsx` for general site information. `PostCard.jsx` is used to display individual blog post summaries.
    -   **`/app/posts`**: Contains the frontend pages related to blog posts.
        -   **`/app/posts/new`**: The page for creating a new blog post, including the form for title, content, and image upload.
        -   **`/app/posts/[id]`**: The dynamic page for viewing a single blog post.
    -   **`/app/styles`**: Contains global CSS files, such as `globals.css`, for styling the application using Tailwind CSS.
    -   **`layout.js`**: The root layout for the application, defining the overall structure and shared UI elements.
    -   **`page.js`**: The main entry point for the application, typically the home page.
-   **`/lib`**: Contains utility functions and configurations that are shared across different parts of the application.
    -   **`prisma.js`**: Initializes the Prisma client, providing a convenient way to interact with the database.
    -   **`utils.js`**: A general utility file for helper functions.
-   **`/prisma`**: This directory holds the Prisma schema and migration files, defining the database models and managing database changes.
    -   **`schema.prisma`**: Defines the database schema, including the `Post` model with fields for title, content, image URL, and timestamps.
    -   **`/prisma/migrations`**: Stores database migration files generated by Prisma, ensuring database schema changes are tracked and applied systematically.
-   **`/public`**: Static assets like images and favicons that are served directly by Next.js.
-   **`package.json`**: Defines project metadata and manages dependencies. It lists all the required packages for the project, including Next.js, React, Prisma, and other libraries.
-   **`next.config.mjs`**: Next.js configuration file.
-   **`postcss.config.mjs`**: PostCSS configuration for Tailwind CSS.
-   **`tailwind.config.js`**: Tailwind CSS configuration file.




## Technical Choices

This mini-blog application is built using a modern web development stack, leveraging the power and flexibility of several key technologies:

### Next.js (App Router)

**Choice Rationale**: Next.js was chosen as the primary framework for its robust features, including server-side rendering (SSR), static site generation (SSG), and API routes. The App Router, introduced in Next.js 13, provides a powerful and flexible way to build full-stack applications with React components, allowing for co-location of data fetching, rendering, and logic. This simplifies development by keeping related code together and enables efficient data loading strategies.

**Implementation**: The application utilizes the App Router for defining pages and API endpoints. Pages like `/app/page.js` and `/app/posts/new/page.js` are React components rendered by Next.js. API routes under `/app/api` handle all backend interactions, such as fetching and creating posts.

### React

**Choice Rationale**: React is used for building the user interface due to its component-based architecture, which promotes reusability and modularity. Its declarative nature makes it easier to develop interactive and dynamic UIs.

**Implementation**: All frontend components, from the main `layout.js` to smaller elements like `Header.jsx` and `PostCard.jsx`, are built using React. State management within components is handled using React Hooks (`useState`, `useRef`).

### Prisma

**Choice Rationale**: Prisma is an open-source ORM (Object-Relational Mapper) that simplifies database access and management. It provides a type-safe and intuitive way to interact with databases, abstracting away raw SQL queries. Its schema-first approach and automatic migrations make database development efficient and less error-prone.

**Implementation**: Prisma is configured to use SQLite as the database, which is suitable for a mini-blog application due to its lightweight and file-based nature. The `schema.prisma` file defines the `Post` model, mapping directly to the database table. The `prisma.js` file in the `/lib` directory initializes the Prisma client, which is then used in API routes (e.g., `/app/api/posts/route.js`) to perform CRUD (Create, Read, Update, Delete) operations on blog posts.

### Tailwind CSS

**Choice Rationale**: Tailwind CSS is a utility-first CSS framework that enables rapid UI development by providing a set of low-level utility classes. This approach allows for highly customizable designs without writing custom CSS, leading to smaller CSS bundles and faster development cycles.

**Implementation**: The application uses Tailwind CSS for all its styling. Classes like `flex`, `py-4`, `mb-8`, `bg-white/80`, `rounded-xl`, and `shadow-sm` are extensively used in JSX components to style elements directly. This eliminates the need for separate CSS files for individual components, streamlining the styling process.

### Cloudinary

**Choice Rationale**: Cloudinary is a cloud-based image and video management solution. It was chosen for handling image uploads, storage, and delivery. This offloads the burden of managing media assets from the application server, providing features like image optimization, transformations, and secure storage.

**Implementation**: The application integrates with Cloudinary for image uploads. When a user creates a new post with an image, the image is first uploaded to Cloudinary via the `/api/posts/upload` endpoint. Cloudinary returns a secure URL and a public ID for the uploaded image, which are then stored in the database along with the post details. This allows for efficient retrieval and display of images in the blog posts.

### Other Libraries and Tools

-   **`framer-motion`**: Used for animations and transitions, providing a smooth and engaging user experience (e.g., in `Header.jsx`).
-   **`lucide-react`**: A collection of beautiful and customizable open-source icons, used throughout the application for visual cues (e.g., `Home`, `PenSquare`, `NotebookText` icons in `Header.jsx`).
-   **`react-hot-toast`**: A lightweight and customizable toast notification library for displaying success or error messages to the user.
-   **ESLint**: For code linting, ensuring code quality and consistency.




## Getting Started

To get a local copy up and running, follow these simple steps.

### Prerequisites

Make sure you have the following installed on your machine:

-   Node.js (LTS version recommended)
-   npm or Yarn
-   Git

### Installation

1.  **Clone the repository:**

    ```bash
    git clone https://github.com/yahyalegrini24/mini-blog.git
    cd mini-blog
    ```

2.  **Install dependencies:**

    ```bash
    npm install
    # or
    yarn install
    ```

3.  **Set up environment variables:**

    Create a `.env` file in the root of the project and add the following:

    ```
    DATABASE_URL="file:./prisma/dev.db"
    NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME="your_cloudinary_cloud_name"
    CLOUDINARY_API_KEY="your_cloudinary_api_key"
    CLOUDINARY_API_SECRET="your_cloudinary_api_secret"
    ```

    -   `DATABASE_URL`: This is configured for a local SQLite database. You can change it to another database provider supported by Prisma (e.g., PostgreSQL, MySQL).
    -   `NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME`, `CLOUDINARY_API_KEY`, `CLOUDINARY_API_SECRET`: These are required for image uploads to Cloudinary. You can obtain these credentials by signing up for a free Cloudinary account.

4.  **Initialize Prisma and generate the database schema:**

    ```bash
    npx prisma migrate dev --name init
    ```

    This command will create the `dev.db` file in the `prisma` directory and apply the necessary migrations.

### Running the Development Server

To run the application in development mode:

```bash
npm run dev
# or
yarn dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

### Building for Production

To build the application for production:

```bash
npm run build
# or
yarn build
```

To start the production server:

```bash
npm run start
# or
yarn start
```


